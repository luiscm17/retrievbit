---
import type { TrainingEntry, MenuItem } from "@/types";
import EntryLayout from "@components/training/EntryLayout.astro";
import CollectionLayout from "@components/training/CollectionLayout.astro";
import { getEntries, getEntriesInGroup, getGroups } from "@lib/contentParser";
import { sortByChapter } from "@lib/sortFunctions";
import { getCollection as getAstroCollection } from "astro:content";

// Usar "en" directamente ya que estamos en la carpeta /en/docs/
const lang = "en";

export async function getStaticPaths() {
  const entries = (await getEntries("training", "en", undefined, false, true)) as TrainingEntry[];

  const paths = entries.map((entry) => {
    const isGroupPage = entry.id.endsWith("-index");
    const slugParts = entry.id.split("/").slice(2);
    let slug: string | undefined;

    if (isGroupPage) {
      // Si es una página de grupo, el slug es la ruta sin el '-index'
      slug = slugParts.slice(0, -1).join("/") || undefined;
    } else {
      // Si es una página de contenido, el slug es la ruta completa
      slug = slugParts.join("/");
    }

    return {
      params: { id: slug },
      props: { entry, isGroup: isGroupPage },
    };
  });

  return paths;
}

const { entry, isGroup } = Astro.props;
const segments = entry.id.split("/");
// El nombre del grupo está en el tercer segmento (índice 2) para /en/training/characters
const groupName = segments[2];

let groupEntries: TrainingEntry[] = [];
if (isGroup) {
  groupEntries = (await getEntriesInGroup("training", lang, groupName, sortByChapter)) as TrainingEntry[];
}

// Construir menú del navegador
const browserMenu: MenuItem[] = [];
const groups = (await getGroups("training", lang, sortByChapter)) as TrainingEntry[];

for (const group of groups) {
  const groupSlug = group.id.split("/").slice(2, -1).join("/") || "";
  const groupName = groupSlug.split("/").pop() || "";

  const groupEntries = (await getEntriesInGroup(
    "training",
    lang,
    groupName,
    sortByChapter,
  )) as TrainingEntry[];

  browserMenu.push({
    title: group.data.title,
    id: groupName, // Usar solo el nombre del grupo
    children: groupEntries.map((entry) => {
      // Extraer solo el nombre del archivo sin la ruta completa
      const entryId = entry.id.split("/").pop()?.replace(/\.mdx?$/, '') || "";
      return {
        title: entry.data.title,
        id: entryId,
        children: [],
      };
    }),
  });
}
---

{
  isGroup ? (
    <CollectionLayout collectionIndex={entry} entries={groupEntries} />
  ) : (
    <EntryLayout entry={entry} browserMenu={browserMenu} />
  )
}
